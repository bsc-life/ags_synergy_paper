# This script takes the topN curves (top 10, 20, 50, 100) from the CSV and averages them and does a lineplot
# Input are the CSV files from the CMA and GA runs

import os
import sys
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy import interpolate
from scipy.stats import pearsonr
import logging
import gc
from functools import lru_cache
from concurrent.futures import ProcessPoolExecutor

# Set up basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Global cache to store processed data
DATA_CACHE = {}

def get_strategy_from_filename(filename):
    if "CMA" in filename:
        return "CMA"
    elif "GA" in filename:
        return "GA"
    elif "sweep" in filename:
        return "sweep"
    else:
        raise ValueError("Strategy not detected")

def get_drug_from_filename(filename):
    if "PI3K" in filename:
        return "PI3K"
    elif "MEK" in filename:
        return "MEK"
    elif "AKT" in filename:
        return "AKT"
    elif "CTRL" in filename:
        return "WT"
    elif "pi3k_mek" in filename:
        return "PI3K_MEK"
    elif "akt_mek" in filename:
        return "AKT_MEK"
    else:
        return "Unknown experiment name"

@lru_cache(maxsize=32)
def get_min_max_wt_exp_curve(input_df_path):
    """
    Optimized version that uses caching and file path instead of DataFrame
    """
    # Load the data file if path is provided
    cache_key = f"min_max_wt_{input_df_path}"
    if cache_key in DATA_CACHE:
        return DATA_CACHE[cache_key]
    
    df_control_csv = pd.read_csv(input_df_path)
    df_control = df_control_csv.reset_index(inplace=False)
    df_control.Time = df_control.Time / 60
    
    # Use vectorized operations
    df_control['Average_Cell_Index'] = df_control.iloc[:,2:].mean(axis=1)
    df_control = df_control[["Time", "Average_Cell_Index"]]
    df_control_sliced = df_control.loc[df_control["Time"] < 4200]

    try:
        f = interpolate.interp1d(df_control.Time, df_control.Average_Cell_Index, kind="cubic", fill_value="extrapolate")
        xnew_control_exp = np.arange(0, 4200, 40)
        ynew_control_exp = f(xnew_control_exp)
    except ValueError:
        f = interpolate.interp1d(df_control.Time, df_control.Average_Cell_Index, kind="cubic", bounds_error=False, fill_value="extrapolate")
        xnew_control_exp = np.arange(0, 4200, 40)
        ynew_control_exp = f(xnew_control_exp)
    
    # Use numpy operations for better performance
    max_value_wt_exp = float(np.max(ynew_control_exp))
    min_value_wt_exp = float(np.min(ynew_control_exp))

    # Cache the result
    result = (min_value_wt_exp, max_value_wt_exp)
    DATA_CACHE[cache_key] = result
    
    return result

def normalize_exp_curve(exp_df_path, min_val, max_val):
    """
    Optimized version that uses caching and file path instead of DataFrame
    """
    cache_key = f"norm_exp_{exp_df_path}_{min_val}_{max_val}"
    if cache_key in DATA_CACHE:
        return DATA_CACHE[cache_key]
    
    # Load the data file
    df_drug_csv = pd.read_csv(exp_df_path)
    df_drug = df_drug_csv.reset_index(inplace=False)
    df_drug.Time = df_drug.Time / 60
    df_drug['Average_Cell_Index'] = df_drug.iloc[:,2:].mean(axis=1)
    df_drug['Std_Cell_Index'] = df_drug.iloc[:,2:].std(axis=1)
    df_drug = df_drug[["Time", "Average_Cell_Index", "Std_Cell_Index"]]

    # Filter data more efficiently
    df_drug = df_drug[(df_drug['Time'] < 400.0) | (df_drug["Time"] > 2500.0)]
    df_drug_sliced = df_drug.loc[df_drug["Time"] < 4200]

    try:
        f_mean = interpolate.interp1d(df_drug.Time, df_drug.Average_Cell_Index, kind="cubic", fill_value="extrapolate")
        f_std = interpolate.interp1d(df_drug.Time, df_drug.Std_Cell_Index, kind="cubic", fill_value="extrapolate")
        xnew_drug_exp = np.arange(0, 4240, 40)
        ynew_drug_exp = f_mean(xnew_drug_exp)
        ynew_drug_std = f_std(xnew_drug_exp)
    except ValueError:
        f_mean = interpolate.interp1d(df_drug.Time, df_drug.Average_Cell_Index, kind="cubic", bounds_error=False, fill_value="extrapolate")
        f_std = interpolate.interp1d(df_drug.Time, df_drug.Std_Cell_Index, kind="cubic", bounds_error=False, fill_value="extrapolate")
        xnew_drug_exp = np.arange(0, 4240, 40)
        ynew_drug_exp = f_mean(xnew_drug_exp)
        ynew_drug_std = f_std(xnew_drug_exp)

    # Vectorized normalization
    tmp_norm = ((ynew_drug_exp-min_val)/(max_val-min_val)) * 100
    tmp_norm_std = (ynew_drug_std / (max_val - min_val)) * 100
    
    # Cache and return the result
    result = (xnew_drug_exp, tmp_norm, tmp_norm_std)
    DATA_CACHE[cache_key] = result
    
    return result

def get_min_max_wt_sim_curve(input_df):
    """
    Optimized version that uses numpy for better performance
    """
    cache_key = f"min_max_wt_sim_{id(input_df)}"
    if cache_key in DATA_CACHE:
        return DATA_CACHE[cache_key]
    
    initial_cell_number = input_df['alive'].iloc[0]
    min_value = input_df['alive'].min()
    max_value = input_df['alive'].max()
    
    result = (min_value, max_value, initial_cell_number)
    DATA_CACHE[cache_key] = result
    
    return result

def normalize_simulation_growth_curve(sim_drug_df, initial_cell_number, min_val, max_val):
    """
    Optimized version with vectorized operations
    """
    cache_key = f"norm_sim_{id(sim_drug_df)}_{initial_cell_number}_{min_val}_{max_val}"
    if cache_key in DATA_CACHE:
        return DATA_CACHE[cache_key]
    
    df = sim_drug_df.copy()
    
    # Calculate the range and normalize in one step
    value_range = max_val - min_val
    df['normalized_alive'] = ((df['alive'] - min_val) / value_range) * 100
    
    result = (df.time.values, df.normalized_alive.values)
    DATA_CACHE[cache_key] = result
    
    return result

def normalize_sim_curve_control(input_df):
    """
    Optimized version with better groupby performance
    """
    cache_key = f"norm_sim_ctrl_{id(input_df)}"
    if cache_key in DATA_CACHE:
        return DATA_CACHE[cache_key]
    
    # Filter non-alive cells
    df = input_df[input_df['current_phase'] != 'alive'].copy()
    
    # Calculate cell counts efficiently
    df['alive_cell_number'] = df.groupby('time')['ID'].transform('nunique')
    initial_cell_number = df.loc[0, 'alive_cell_number']

    # Create subset with only needed columns
    subset_df = df.loc[:, ['time', 'alive_cell_number']].copy()
    subset_df['adjusted_alive_cell_number'] = subset_df['alive_cell_number'] - initial_cell_number

    # Calculate min/max values
    max_value = subset_df['adjusted_alive_cell_number'].max()
    min_value = subset_df['adjusted_alive_cell_number'].min()
    
    # Normalize in one step
    subset_df['normalized_alive_cell_number'] = ((subset_df['adjusted_alive_cell_number'] - min_value) / 
                                               (max_value - min_value)) * 100

    # Remove duplicates
    df_unique = subset_df.drop_duplicates()
    
    result = (df_unique.time.values, df_unique.normalized_alive_cell_number.values)
    DATA_CACHE[cache_key] = result
    
    return result

def load_drug_data(experimental_data_path, drug_name):
    """
    Optimized version with caching based on path and drug name
    """
    cache_key = f"drug_data_{experimental_data_path}_{drug_name}"
    if cache_key in DATA_CACHE:
        return DATA_CACHE[cache_key]
    
    # Map drug names to file paths
    drug_file_map = {
        "PI3K": "PI103(0.70uM).csv",
        "MEK": "PD0325901(35.00nM).csv",
        "TAK1": "(5Z)-7-oxozeaenol(0.50uM).csv",
        "AKT": "AKT_2.csv",
        "WT": "CTRL.csv",
        "PI3K_MEK": "PD0325901(17.50nM)+PI103(0.35uM).csv",
        "AKT_MEK": "AKT_MEK_final_ok.csv"
    }
    
    if drug_name not in drug_file_map:
        raise ValueError(f"Unknown drug name: {drug_name}")
    
    file_path = os.path.join(experimental_data_path, drug_file_map[drug_name])
    
    try:
        exp_drug_df = pd.read_csv(file_path)
        
        # Calculate statistics efficiently
        y_exp = exp_drug_df.iloc[:, 1:].mean(axis=1).values
        y_exp_std = exp_drug_df.iloc[:, 1:].std(axis=1).values
        
        result = (exp_drug_df, y_exp, y_exp_std)
        DATA_CACHE[cache_key] = result
        
        return result
    except Exception as e:
        logging.error(f"Error loading drug data for {drug_name}: {str(e)}")
        raise

@lru_cache(maxsize=1)
def get_experiment_color_scheme():
    """Cache the color scheme since it never changes"""
    return {
        'control': {
            'exp': '#808080',  # Medium grey for experimental
            'sim': '#A9A9A9'   # Lighter grey for simulation
        },
        'PI3Ki': {
            'exp': '#1E88E5',  # Professional blue for experimental
            'sim': '#64B5F6'   # Lighter blue for simulation
        },
        'MEKi': {
            'exp': '#2E7D32',  # Professional green for experimental
            'sim': '#81C784'   # Lighter green for simulation
        },
        'AKTi': {
            'exp': '#7B1FA2',  # Professional purple for experimental
            'sim': '#BA68C8'   # Lighter purple for simulation
        },
        'pi3k_mek': {
            'exp': '#F57C00',  # Professional orange for experimental
            'sim': '#FFB74D'   # Lighter orange for simulation
        },
        'akt_mek': {
            'exp': '#E65100',  # Darker orange for experimental
            'sim': '#FF8F00'   # Lighter orange for simulation
        }
    }

def get_experiment_colors(exp_name):
    """Get colors based on experiment name"""
    color_scheme = get_experiment_color_scheme()
    exp_type = exp_name.lower()
    
    if exp_type == "wt" or exp_type == "ctrl" or 'control' in exp_type:
        return color_scheme['control']
    elif ('pi3k_mek' in exp_type) or ('pi3kmek' in exp_type):
        return color_scheme['pi3k_mek']
    elif ('akt_mek' in exp_type) or ('aktmek' in exp_type):
        return color_scheme['akt_mek']
    elif 'pi3k' in exp_type:
        return color_scheme['PI3Ki']
    elif 'mek' in exp_type:
        return color_scheme['MEKi']
    elif 'akt' in exp_type:
        return color_scheme['AKTi']
    else:
        return color_scheme['control']  # Default to control colors

def process_top_10(csv_path, experiment_name, experimental_data_path, drug_name, top_n, nodrug=False):
    """
    Optimized process_top_10 function with caching and output file checking
    """
    # Check if output files already exist
    output_dir = os.path.dirname(csv_path)
    plot_path_png = os.path.join(output_dir, f'growth_comparison_{drug_name}_top{top_n}.png')
    correlation_results_path = os.path.join(output_dir, f'pearson_correlation_{drug_name}_top{top_n}.txt')
    
    if os.path.exists(plot_path_png) and os.path.exists(correlation_results_path):
        logging.info(f"Output files for {experiment_name} already exist, loading from cache...")
        cache_key = f"process_top10_{csv_path}_{experiment_name}_{drug_name}_{top_n}"
        if cache_key in DATA_CACHE:
            return DATA_CACHE[cache_key]
    
    logging.info(f"Processing {experiment_name} with drug {drug_name}...")
    
    # Read the summary CSV
    raw_df = pd.read_csv(csv_path)
    fitness_column = raw_df.columns[-1]

    # If it's a sweep, sort by fitness and take the top N
    if get_strategy_from_filename(experiment_name) == "sweep":
        # For sweeps, the fitness metric is in the last column (e.g., 'RMSE_SK_POSTDRUG')
        logging.info(f"Using column '{fitness_column}' to sort sweep results for {experiment_name}.")
        # Assuming lower fitness is better, as is common with RMSE
        top_10_df = raw_df.sort_values(by=fitness_column, ascending=True).head(top_n)
    else:
        top_10_df = raw_df.head(top_n)
    
    rmses = top_10_df[fitness_column].tolist()

    # Get the experiment folder
    experiment_folder = os.path.join("experiments", experiment_name)

    # Load WT reference data once
    sim_wt_path = f'{experimental_data_path}SIM_CTRL_CMA-1110-1637-5p.csv'
    sim_wt_df = pd.read_csv(sim_wt_path)

    # Initialize a list to store all simulation growth dataframes
    all_sim_growths = []
    
    # Process each row in the top 10 CSV
    for _, row in top_10_df.iterrows():
        # Build instance folder name
        if "iteration" in row.index:
            instance_folder = f"instance_{int(row['iteration'])}_{int(row['individual'])}_{int(row['replicate'])}"
        else:
            instance_folder = f"instance_{int(row['individual'])}_{int(row['replicate'])}"

        # Check for both compression types
        full_path_gzip = os.path.join(experiment_folder, instance_folder, 'pcdl_total_info_sim.csv.gz')
        full_path_bz2 = os.path.join(experiment_folder, instance_folder, 'pcdl_total_info_sim.csv.bz2')
        
        if os.path.exists(full_path_gzip):
            full_path = full_path_gzip
            compression = 'gzip'
        elif os.path.exists(full_path_bz2):
            full_path = full_path_bz2
            compression = 'bz2'
        else:
            logging.warning(f"Neither {full_path_gzip} nor {full_path_bz2} exists for {instance_folder}.")
            continue
        
        # Process the simulation file if it exists
        try:
            # Generate cache key based on file path and modification time
            file_mtime = os.path.getmtime(full_path)
            sim_cache_key = f"{full_path}_{file_mtime}"
            
            if sim_cache_key in DATA_CACHE:
                sim_growth = DATA_CACHE[sim_cache_key]
            else:
                # Read the compressed file
                full_sim_df = pd.read_csv(full_path, compression=compression)
                
                if drug_name == "WT":
                    # Use control normalization
                    x_sim, y_sim = normalize_sim_curve_control(full_sim_df)
                else:
                    # Get WT min/max and normalize accordingly
                    wt_min_sim, wt_max_sim, initial_cells = get_min_max_wt_sim_curve(sim_wt_df)
                    
                    # Get simulation growth data
                    simgrowth_path = os.path.join(experiment_folder, instance_folder, "simulation_growth.csv")
                    if not os.path.exists(simgrowth_path):
                        logging.warning(f"Simulation growth file not found: {simgrowth_path}")
                        continue
                        
                    simgrowth_reduced_df = pd.read_csv(simgrowth_path)
                    x_sim, y_sim = normalize_simulation_growth_curve(simgrowth_reduced_df, initial_cells, wt_min_sim, wt_max_sim)  

                # Create dataframe with results
                sim_growth = pd.DataFrame({
                    "time": x_sim,
                    "alive": y_sim,
                    'instance': instance_folder
                })
                
                # Cache for future use
                DATA_CACHE[sim_cache_key] = sim_growth
            
            all_sim_growths.append(sim_growth)
            
        except Exception as e:
            logging.error(f"Error processing {instance_folder}: {str(e)}")
            continue
    
    # Check if we have any data
    if not all_sim_growths:
        logging.error(f"No valid simulation files found for {experiment_name}")
        return None
    
    # Combine simulation data and calculate statistics
    combined_sim_growth = pd.concat(all_sim_growths, ignore_index=True)
    sim_stats = combined_sim_growth.groupby('time').agg({'alive': ['mean', 'std']}).reset_index()
    sim_stats.columns = ['time', 'mean_alive', 'std_alive']
    
    # Process experimental data
    try:
        # Load experimental files
        exp_wt_path = f'{experimental_data_path}/CTRL.csv'
        exp_drug_df, y_exp, y_exp_std = load_drug_data(experimental_data_path, drug_name)
        
        # Get min/max values for normalization
        wt_min_exp, wt_max_exp = get_min_max_wt_exp_curve(exp_wt_path)
        
        # Get the appropriate drug file path
        drug_file_map = {
            "PI3K": "PI103(0.70uM).csv",
            "MEK": "PD0325901(35.00nM).csv",
            "TAK1": "(5Z)-7-oxozeaenol(0.50uM).csv",
            "AKT": "AKT_2.csv",
            "WT": "CTRL.csv",
            "PI3K_MEK": "PD0325901(17.50nM)+PI103(0.35uM).csv",
            "AKT_MEK": "AKT_MEK_final_ok.csv"
        }
        drug_file = drug_file_map.get(drug_name, "CTRL.csv")
        drug_path = os.path.join(experimental_data_path, drug_file)
        
        # Normalize experimental data
        x_exp, y_exp, y_exp_std = normalize_exp_curve(drug_path, wt_min_exp, wt_max_exp)
        
        # Calculate Pearson correlation
        y_sim = sim_stats["mean_alive"][:len(y_exp)]
        pearson_corr, p_value = pearsonr(y_sim, y_exp)
        
        # Save correlation results
        with open(correlation_results_path, 'w') as f:
            f.write(f'Pearson correlation: {pearson_corr}\n')
            f.write(f'p-value: {p_value}\n')
    except Exception as e:
        logging.error(f"Error processing experimental data: {str(e)}")
        x_exp, y_exp, y_exp_std = np.array([]), np.array([]), np.array([])
        pearson_corr, p_value = 0, 1
    
    # Align AKT and AKT-MEK data by removing the last point from all relevant dataframes
    if "AKT" in drug_name or "AKT_MEK" in drug_name:
        if len(x_exp) > 0:
            x_exp = x_exp[:-1]
            y_exp = y_exp[:-1]
            y_exp_std = y_exp_std[:-1]
        if not sim_stats.empty:
            sim_stats = sim_stats.iloc[:-1]

    # Create the plot
    try:
        # Set up figure with appropriate size for a 4-panel horizontal layout
        fig, ax = plt.subplots(figsize=(1.67, 2.5), dpi=300)
        sns.set_context("paper", font_scale=1.0)
        sns.set_style("ticks")
        
        # Set font properties
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Helvetica', 'Liberation Sans', 
                                          'FreeSans', 'Arial', 'sans-serif']
        
        # Get colors for this experiment type
        colors = get_experiment_colors(drug_name)
        
        # Plot experimental data if available
        if len(x_exp) > 0:
            ax.plot(x_exp[::3], y_exp[::3],  
                    label='Experimental',
                    color=colors['exp'],
                    marker='o',  
                    markersize=1.5,
                    linewidth=1.2,
                    zorder=3)
            ax.fill_between(x_exp[::3], 
                            (y_exp - y_exp_std)[::3],
                            (y_exp + y_exp_std)[::3],
                            color=colors['exp'],
                            alpha=0.15,
                            zorder=2)
        
        # Plot simulation data
        ax.plot(sim_stats['time'], 
                sim_stats['mean_alive'],
                label='Simulation (mean)', 
                color=colors['sim'],
                linewidth=1.5,
                alpha=0.9,
                zorder=2)
        ax.fill_between(sim_stats['time'], 
                        sim_stats['mean_alive'] - sim_stats['std_alive'],
                        sim_stats['mean_alive'] + sim_stats['std_alive'],
                        alpha=0.08,
                        color=colors['sim'],
                        zorder=1)
        
        # Add treatment window if not nodrug
        if not nodrug:
            ax.axvspan(1280, 1292, 
                        color='#808080', 
                        alpha=1.0,
                        zorder=0,
                        label='Treatment')
        
        # Customize plot appearance
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_linewidth(0.8)
        ax.spines['bottom'].set_linewidth(0.8)
        ax.set_xlabel('Time (min)', fontsize=8, fontweight="bold")
        ax.set_ylabel('Normalized Cell Count', fontsize=8, fontweight="bold")
        ax.tick_params(axis='both', width=0.8, length=2, labelsize=7, colors='black')
        ax.set_xlim(0, 4200)
        ax.set_ylim(0, None)
        
        # Save the main plot (PNG and SVG)
        fig.savefig(plot_path_png, dpi=300, bbox_inches='tight', transparent=True)
        fig.savefig(plot_path_png.replace('.png', '.svg'), format='svg', bbox_inches='tight', transparent=True)
        
        # Create a separate legend figure
        legend_fig = plt.figure(figsize=(1.67, 0.5))
        legend_ax = legend_fig.add_subplot(111)
        legend_ax.axis('off')
        handles, labels = ax.get_legend_handles_labels()
        legend = legend_ax.legend(handles, labels,
                                  frameon=True,
                                  fontsize=7,
                                  loc='center',
                                  ncol=2)
        legend_fig.savefig(plot_path_png.replace('.png', '_legend.png'), dpi=300, bbox_inches='tight', transparent=True)
        legend_fig.savefig(plot_path_png.replace('.png', '_legend.svg'), format='svg', bbox_inches='tight', transparent=True)
        
        logging.info(f"Top N plot saved to {plot_path_png}")
        logging.info(f"Legend saved to {plot_path_png.replace('.png', '_legend.png')}")
        logging.info(f"Top N plot saved to {plot_path_png.replace('.png', '.svg')}")
        logging.info(f"Legend saved to {plot_path_png.replace('.png', '_legend.svg')}")
        
        # Clean up plots to save memory
        plt.close(fig)
        plt.close(legend_fig)
        
    except Exception as e:
        logging.error(f"Error creating plot: {str(e)}")
        plt.close()
    
    # Cache results for future use
    result = (sim_stats, x_exp, y_exp, y_exp_std, rmses)
    DATA_CACHE[f"process_top10_{csv_path}_{experiment_name}_{drug_name}_{top_n}"] = result
    
    # Clean up memory
    gc.collect()
    
    return result

def process_last_gen(experiment_name, experimental_data_path, drug_name):
    """
    Optimized process_last_gen function with caching and file checks
    """
    # Set up output paths for checking if files exist
    strategy = get_strategy_from_filename(experiment_name)
    summary_folder = f'results/{strategy}_summaries/'
    plot_path_png = os.path.join(summary_folder, f"final_summary_{experiment_name}", 
                              f'growth_comparison_{drug_name}_lastgen.png')
    correlation_results_path = os.path.join(summary_folder, f'pearson_correlation_{drug_name}_lastgen.txt')
    
    # Check if outputs already exist
    if os.path.exists(plot_path_png) and os.path.exists(correlation_results_path):
        logging.info(f"Last generation outputs for {experiment_name} already exist, loading from cache...")
        cache_key = f"process_lastgen_{experiment_name}_{drug_name}"
        if cache_key in DATA_CACHE:
            return DATA_CACHE[cache_key]
    
    logging.info(f"Processing last generation for {experiment_name} with drug {drug_name}...")
    
    # Get experiment folder
    experiment_folder = os.path.join("experiments", experiment_name)
    
    # Load WT reference data
    sim_wt_path = f'{experimental_data_path}SIM_CTRL_CMA-1110-1637-5p.csv'
    sim_wt_df = pd.read_csv(sim_wt_path)
    
    # Find summary folder and file
    summary_file = os.path.join(summary_folder, f'final_summary_{experiment_name}.csv')
    
    # Make sure the summary file exists
    if not os.path.exists(summary_file):
        logging.error(f"Summary file not found: {summary_file}")
        return None
    
    # Read summary file
    summary_df = pd.read_csv(summary_file)
    
    # Get last generation data
    try:
        last_gen = summary_df['iteration'].max()
        last_gen_df = summary_df[summary_df['iteration'] == last_gen]
    except KeyError:
        logging.error(f"Could not find 'iteration' column in {summary_file}")
        return None
    
    # Initialize a list to store all simulation growth dataframes
    all_sim_growths = []
    
    # Process each individual in the last generation
    for _, row in last_gen_df.iterrows():
        # Build instance folder name
        if "iteration" in row.index:
            instance_folder = f"instance_{int(row['iteration'])}_{int(row['individual'])}_{int(row['replicate'])}"
        else:
            instance_folder = f"instance_{int(row['individual'])}_{int(row['replicate'])}"
        
        # Check for both compression types
        full_path_gzip = os.path.join(experiment_folder, instance_folder, 'pcdl_total_info_sim.csv.gz')
        full_path_bz2 = os.path.join(experiment_folder, instance_folder, 'pcdl_total_info_sim.csv.bz2')
        
        if os.path.exists(full_path_gzip):
            full_path = full_path_gzip
            compression = 'gzip'
        elif os.path.exists(full_path_bz2):
            full_path = full_path_bz2
            compression = 'bz2'
        else:
            continue  # Skip if file doesn't exist
        
        # Process the simulation file
        try:
            # Check if already in cache
            file_mtime = os.path.getmtime(full_path)
            sim_cache_key = f"{full_path}_{file_mtime}"
            
            if sim_cache_key in DATA_CACHE:
                sim_growth = DATA_CACHE[sim_cache_key]
            else:
                # Read and process file
                full_sim_df = pd.read_csv(full_path, compression=compression)
                
                if drug_name == "WT":
                    x_sim, y_sim = normalize_sim_curve_control(full_sim_df)
                else:
                    wt_min_sim, wt_max_sim, initial_cells = get_min_max_wt_sim_curve(sim_wt_df)
                    
                    simgrowth_path = os.path.join(experiment_folder, instance_folder, "simulation_growth.csv")
                    if not os.path.exists(simgrowth_path):
                        continue
                        
                    simgrowth_reduced_df = pd.read_csv(simgrowth_path)
                    x_sim, y_sim = normalize_simulation_growth_curve(simgrowth_reduced_df, initial_cells, wt_min_sim, wt_max_sim)
                
                # Create dataframe with results
                sim_growth = pd.DataFrame({
                    "time": x_sim,
                    "alive": y_sim,
                    'instance': instance_folder
                })
                
                # Cache for future use
                DATA_CACHE[sim_cache_key] = sim_growth
            
            all_sim_growths.append(sim_growth)
            
        except Exception as e:
            logging.error(f"Error processing {instance_folder}: {str(e)}")
            continue
    
    # Check if we have any valid data
    if not all_sim_growths:
        logging.error(f"No valid simulation files found for last generation of {experiment_name}")
        return None
    
    # Combine all growth curves and calculate statistics
    combined_sim_growth = pd.concat(all_sim_growths, ignore_index=True)
    sim_stats = combined_sim_growth.groupby('time').agg({'alive': ['mean', 'std']}).reset_index()
    sim_stats.columns = ['time', 'mean_alive', 'std_alive']
    
    # Process experimental data
    try:
        # Load experimental data
        exp_wt_path = f'{experimental_data_path}/CTRL.csv'
        exp_drug_df, y_exp, y_exp_std = load_drug_data(experimental_data_path, drug_name)
        
        # Get min/max values for normalization
        wt_min_exp, wt_max_exp = get_min_max_wt_exp_curve(exp_wt_path)
        
        # Get the appropriate drug file path
        drug_file_map = {
            "PI3K": "PI103(0.70uM).csv",
            "MEK": "PD0325901(35.00nM).csv",
            "TAK1": "(5Z)-7-oxozeaenol(0.50uM).csv",
            "AKT": "AKT_2.csv",
            "WT": "CTRL.csv",
            "PI3K_MEK": "PD0325901(17.50nM)+PI103(0.35uM).csv",
            "AKT_MEK": "AKT_MEK_final_ok.csv"
        }
        drug_file = drug_file_map.get(drug_name, "CTRL.csv")
        drug_path = os.path.join(experimental_data_path, drug_file)
        
        # Normalize experimental data
        x_exp, y_exp, y_exp_std = normalize_exp_curve(drug_path, wt_min_exp, wt_max_exp)
        
        # Calculate correlation
        y_sim = sim_stats["mean_alive"][:len(y_exp)]
        pearson_corr, p_value = pearsonr(y_sim, y_exp)
        
        # Save correlation results
        os.makedirs(os.path.dirname(correlation_results_path), exist_ok=True)
        with open(correlation_results_path, 'w') as f:
            f.write(f'Pearson correlation: {pearson_corr}\n')
            f.write(f'p-value: {p_value}\n')
    except Exception as e:
        logging.error(f"Error processing experimental data: {str(e)}")
        x_exp, y_exp, y_exp_std = np.array([]), np.array([]), np.array([])
        pearson_corr, p_value = 0, 1
    
    # Align AKT and AKT-MEK data by removing the last point from all relevant dataframes
    if "AKT" in drug_name or "AKT_MEK" in drug_name:
        if len(x_exp) > 0:
            x_exp = x_exp[:-1]
            y_exp = y_exp[:-1]
            y_exp_std = y_exp_std[:-1]
        if not sim_stats.empty:
            sim_stats = sim_stats.iloc[:-1]

    # Create plot
    try:
        # Set up figure with appropriate size for a 4-panel horizontal layout
        fig, ax = plt.subplots(figsize=(1.67, 2.5), dpi=300)
        sns.set_context("paper", font_scale=1.0)
        sns.set_style("ticks")
        
        # Set font properties
        plt.rcParams['font.family'] = 'sans-serif'
        plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Helvetica', 'Liberation Sans', 
                                          'FreeSans', 'Arial', 'sans-serif']
        
        # Get colors for this experiment type
        colors = get_experiment_colors(drug_name)
        
        # Plot experimental data if available
        if len(x_exp) > 0:
            ax.plot(x_exp[::3], y_exp[::3],  
                    label='Experimental',
                    color=colors['exp'],
                    marker='o',
                    markersize=1.5,
                    linewidth=1.2,
                    alpha=0.6,
                    zorder=3)
            ax.fill_between(x_exp[::3], 
                            (y_exp - y_exp_std)[::3],
                            (y_exp + y_exp_std)[::3],
                            color=colors['exp'],
                            alpha=0.15,
                            zorder=2)
        
        # Plot simulation data
        ax.plot(sim_stats['time'], 
                sim_stats['mean_alive'],
                label='Simulation (mean)', 
                color=colors['sim'],
                linewidth=1.5,
                alpha=0.9,
                zorder=2)
        ax.fill_between(sim_stats['time'], 
                        sim_stats['mean_alive'] - sim_stats['std_alive'],
                        sim_stats['mean_alive'] + sim_stats['std_alive'],
                        alpha=0.08,
                        color=colors['sim'],
                        zorder=1)
        
        # Add treatment window
        ax.axvspan(1280, 1292, 
                    color='#808080', 
                    alpha=1.0,
                    zorder=0,
                    label='Treatment')
        
        # Customize plot appearance
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_linewidth(0.8)
        ax.spines['bottom'].set_linewidth(0.8)
        
        # Labels and ticks with adjusted sizes
        ax.set_xlabel('Time (min)', fontsize=8, fontweight="bold")
        ax.set_ylabel('Normalized Cell Count', fontsize=8, fontweight="bold")
        
        # Adjust tick parameters
        ax.tick_params(axis='both', width=0.8, length=2, labelsize=7, colors='black')
        
        ax.set_xlim(0, 4200)
        ax.set_ylim(0, None)
        
        # Save the main plot (PNG and SVG)
        fig.savefig(plot_path_png, dpi=300, bbox_inches='tight', transparent=True)
        fig.savefig(plot_path_png.replace('.png', '.svg'), format='svg', bbox_inches='tight', transparent=True)
        
        # Create a separate legend figure
        legend_fig = plt.figure(figsize=(1.67, 0.5))
        legend_ax = legend_fig.add_subplot(111)
        legend_ax.axis('off')
        handles, labels = ax.get_legend_handles_labels()
        legend = legend_ax.legend(handles, labels,
                                  frameon=True,
                                  fontsize=7,
                                  loc='center',
                                  ncol=2)
        legend_fig.savefig(plot_path_png.replace('.png', '_legend.png'), dpi=300, bbox_inches='tight', transparent=True)
        legend_fig.savefig(plot_path_png.replace('.png', '_legend.svg'), format='svg', bbox_inches='tight', transparent=True)
        
        logging.info(f"Top N plot saved to {plot_path_png}")
        logging.info(f"Legend saved to {plot_path_png.replace('.png', '_legend.png')}")
        logging.info(f"Top N plot saved to {plot_path_png.replace('.png', '.svg')}")
        logging.info(f"Legend saved to {plot_path_png.replace('.png', '_legend.svg')}")
        
        # Clean up plots to save memory
        plt.close(fig)
        plt.close(legend_fig)
        
    except Exception as e:
        logging.error(f"Error creating plot: {str(e)}")
        plt.close()
    
    # Cache results for future use
    result = (sim_stats, x_exp, y_exp, y_exp_std)
    DATA_CACHE[f"process_lastgen_{experiment_name}_{drug_name}"] = result
    
    # Clean up memory
    gc.collect()
    
    return result

def combine_and_plot_experiments(experiment_info, output_dir, plot_filename_base):
    # Set up the figure for a 4-panel horizontal layout
    fig, ax = plt.subplots(figsize=(1.67, 2.5), dpi=300)

    # If you want to double the width for synergy plots, keep this:
    if len(experiment_info) > 2:
        fig.set_figwidth(fig.get_figwidth() * 2)

    sns.set_context("paper", font_scale=1.0)
    sns.set_style("ticks")
    
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = [
        'DejaVu Sans', 'Helvetica', 'Liberation Sans', 'FreeSans', 'Arial', 'sans-serif'
    ]
    
    for idx, exp in enumerate(experiment_info):
        sim_stats, x_exp, y_exp, y_exp_std = exp["data"]
        colors = get_experiment_colors(exp["drug_name"])
        ax.plot(x_exp[::3], y_exp[::3], 
                label=f'{exp["drug_name"]} (exp)', 
                color=colors['exp'],
                marker='o',
                markersize=1.5,
                linewidth=1.2,
                alpha=0.6,
                zorder=3)
        ax.fill_between(x_exp[::3], 
                        (y_exp - y_exp_std)[::3],
                        (y_exp + y_exp_std)[::3],
                        color=colors['exp'],
                        alpha=0.15,
                        zorder=2)
        ax.plot(sim_stats['time'], 
                sim_stats['mean_alive'],
                label=f'{exp["short_name"]} (sim)', 
                color=colors['sim'],
                linewidth=1.5,
                alpha=0.9,
                zorder=2)
        ax.fill_between(sim_stats['time'], 
                        sim_stats['mean_alive'] - sim_stats['std_alive'],
                        sim_stats['mean_alive'] + sim_stats['std_alive'],
                        alpha=0.08,
                        color=colors['sim'],
                        zorder=1)
    ax.axvspan(1280, 1292, color='#808080', alpha=1.0, zorder=0, label='Treatment')
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_linewidth(0.8)
    ax.spines['bottom'].set_linewidth(0.8)
    ax.set_xlabel('Simulation Time (min)', fontsize=8, fontweight="bold")
    # Only set Y label for the first (control) panel
    if len(experiment_info) == 1 or (len(experiment_info) > 1 and experiment_info[0]["drug_name"] in ["WT", "CTRL"]):
        ax.set_ylabel('Normalized Cell Count', fontsize=8, fontweight="bold")
    else:
        ax.set_ylabel("")

        ax.tick_params(axis='both', width=0.8, length=2, labelsize=7, colors='black')
        ax.set_xlim(0, 4200)
        ax.set_ylim(0, None)

    # --- Shorten the filename here ---
    plot_path_base = os.path.join(output_dir, plot_filename_base)

    fig.savefig(plot_path_base + ".png", dpi=300, bbox_inches='tight', transparent=True)
    fig.savefig(plot_path_base + ".svg", format='svg', bbox_inches='tight', transparent=True)

    legend_fig = plt.figure(figsize=(1.67, 0.5))
    legend_ax = legend_fig.add_subplot(111)
    legend_ax.axis('off')
    handles, labels = ax.get_legend_handles_labels()
    legend = legend_ax.legend(handles, labels,
                              frameon=True,
                              fontsize=7,
                              loc='center',
                              ncol=2)
    legend_fig.savefig(plot_path_base + "_legend.png", dpi=300, bbox_inches='tight', transparent=True)
    legend_fig.savefig(plot_path_base + "_legend.svg", format='svg', bbox_inches='tight', transparent=True)

    logging.info(f"Top N plot saved to {plot_path_base}.png")
    logging.info(f"Top N plot saved to {plot_path_base}.svg")
    logging.info(f"Legend saved to {plot_path_base}_legend.png")
    logging.info(f"Legend saved to {plot_path_base}_legend.svg")

    plt.close(fig)
    plt.close(legend_fig)
    return sim_stats, x_exp, y_exp, y_exp_std

def side_by_side_experiment_plots(experiment_info, output_dir, plot_filename_base):
    """
    Create side-by-side plots comparing experimental and simulation growth curves.
    """
    # Set up the figure with high-quality settings
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4), dpi=300)
    sns.set_context("paper", font_scale=1.2)
    sns.set_style("ticks")
    
    # Use sans-serif font
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Helvetica', 'Liberation Sans', 
                                      'FreeSans', 'Arial', 'sans-serif']
    
    # Plot experimental data on left subplot
    for idx, exp in enumerate(experiment_info):
        sim_stats, x_exp, y_exp, y_exp_std = exp["data"]
        
        # Get colors for this experiment type
        colors = get_experiment_colors(exp["drug_name"])

        # Exclude the last point for AKT experimental data
        if "AKT" in exp["drug_name"] or "AKT_MEK" in exp["drug_name"]:
            x_exp = x_exp[:-1]
            y_exp = y_exp[:-1]
            y_exp_std = y_exp_std[:-1]
            sim_stats = sim_stats.iloc[:-1]

        # Experimental data (left subplot) - add alpha
        ax1.plot(x_exp[::3], y_exp[::3],  
                label=f'{exp["drug_name"]}', 
                color=colors['exp'],
                marker='o',
                markersize=2,
                linewidth=1.0,
                alpha=0.6,  # Added alpha
                zorder=1)
        ax1.fill_between(x_exp[::3], 
                        (y_exp - y_exp_std)[::3],
                        (y_exp + y_exp_std)[::3],
                        color=colors['exp'],
                        alpha=0.3,
                        zorder=0)
        
        # Simulation data (right subplot)
        ax2.plot(sim_stats['time'], sim_stats['mean_alive'],
                label=f'{exp["short_name"]}', 
                color=colors['sim'],
                linewidth=1.5,
                alpha=0.9,
                zorder=3)
        ax2.fill_between(sim_stats['time'], 
                        sim_stats['mean_alive'] - sim_stats['std_alive'],
                        sim_stats['mean_alive'] + sim_stats['std_alive'],
                        alpha=0.15,  # Reduced alpha
                        color=colors['sim'],
                        zorder=2)

    # Add treatment period indicator to both plots
    ax1.axvspan(1280, 1292, color='#808080', alpha=1.0, zorder=0, label='Treatment')
    ax2.axvspan(1280, 1292, color='#808080', alpha=1.0, zorder=0, label='Treatment')

    # Customize both subplots
    for ax in [ax1, ax2]:
        # Remove top and right spines
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_linewidth(0.7)
        ax.spines['bottom'].set_linewidth(0.7)
        
        # Set axis limits
        ax.set_xlim(0, 4200)
        ax.set_ylim(0, None)
        
        # Customize ticks
        ax.tick_params(axis='both', width=0.8, length=2, labelsize=12, colors='black')

    # Set titles and labels
    ax1.set_title('Experimental Data', fontsize=13, fontweight="bold", pad=10)
    ax2.set_title('Simulation Data', fontsize=13, fontweight="bold", pad=10)
    
    # Set axis labels
    ax1.set_xlabel('Time (min)', fontsize=13, fontweight="bold")
    ax2.set_xlabel('Time (min)', fontsize=13, fontweight="bold")
    ax1.set_ylabel('Normalized Cell Count', fontsize=13, fontweight="bold")
    ax2.set_ylabel('Normalized Cell Count', fontsize=13, fontweight="bold")

    # Add legends
    ax1.legend(frameon=True, 
              fontsize=12,
              bbox_to_anchor=(0.5, -0.15),
              loc='upper center',
              ncol=2)
    ax2.legend(frameon=True, 
              fontsize=12,
              bbox_to_anchor=(0.5, -0.15),
              loc='upper center',
              ncol=2)

    # Adjust layout to prevent overlap
    plt.tight_layout()
    
    # Save plot
    output_filepath = os.path.join(output_dir, f"{plot_filename_base}_side_by_side")
    plt.savefig(f'{output_filepath}.png', 
                dpi=300, 
                bbox_inches='tight',
                transparent=True)
    plt.savefig(f'{output_filepath}.svg',
                format='svg',
                bbox_inches='tight',
                transparent=True)
    
    plt.close()
    logging.info(f"Side-by-side plot saved to {output_filepath}.png")

def plot_multi_panel_figure(list_of_experiment_groups, num_cols, output_dir, plot_filename_base, is_synergy=False):
    """
    Creates a multi-panel figure, with each panel showing a different experiment group.
    """
    num_panels = len(list_of_experiment_groups)
    num_rows = (num_panels + num_cols - 1) // num_cols  # Calculate rows needed

    # Increase figure width for synergy plots which have more data
    fig_width = 4.5 * num_cols
    fig_height = 3.5 * num_rows

    fig, axes = plt.subplots(num_rows, num_cols, figsize=(fig_width, fig_height), dpi=300, squeeze=False)
    axes = axes.flatten()  # Flatten to 1D array for easy iteration

    sns.set_context("paper", font_scale=1.0)
    sns.set_style("ticks")
    plt.rcParams['font.family'] = 'sans-serif'
    plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Helvetica', 'Liberation Sans', 'FreeSans', 'Arial', 'sans-serif']

    all_handles = []
    all_labels = []

    for i, (experiment_info, ax) in enumerate(zip(list_of_experiment_groups, axes)):
        panel_title = ""
        # Plot each curve in the group
        for exp in experiment_info:
            if exp["data"] is None:
                logging.warning(f"No data for {exp['name']}, skipping plot.")
                continue

            sim_stats, x_exp, y_exp, y_exp_std = exp["data"]
            colors = get_experiment_colors(exp["drug_name"])

            # Determine the label based on what's being plotted
            if exp['drug_name'] == 'WT':
                sim_label = 'Control (Sim)'
                exp_label = 'Control (Exp)'
            else:
                sim_label = f'{exp["drug_name"].replace("_", "+")}i (Sim)'
                exp_label = f'{exp["drug_name"].replace("_", "+")}i (Exp)'

            # Plot simulation data
            p_sim = ax.plot(sim_stats['time'],
                            sim_stats['mean_alive'],
                            label=sim_label,
                            color=colors['sim'],
                            linewidth=1.5,
                            alpha=0.9,
                            zorder=2)
            ax.fill_between(sim_stats['time'],
                            sim_stats['mean_alive'] - sim_stats['std_alive'],
                            sim_stats['mean_alive'] + sim_stats['std_alive'],
                            alpha=0.08,
                            color=colors['sim'],
                            zorder=1)
            
            # Plot experimental data
            p_exp = ax.plot(x_exp[::3], y_exp[::3],
                            label=exp_label,
                            color=colors['exp'],
                            marker='o',
                            markersize=1.5,
                            linewidth=1.2,
                            alpha=0.6,
                            zorder=3)
            ax.fill_between(x_exp[::3],
                            (y_exp - y_exp_std)[::3],
                            (y_exp + y_exp_std)[::3],
                            color=colors['exp'],
                            alpha=0.15,
                            zorder=2)

        # Determine panel title
        main_drug_exp = next((exp for exp in reversed(experiment_info) if exp['drug_name'] != 'WT'), None)
        if main_drug_exp:
            drug_name = main_drug_exp['drug_name'].replace('_', 'i + ')
            if 'i' not in drug_name[-2:]:
                drug_name += 'i'

            if is_synergy:
                panel_title = f"{drug_name} Synergy"
            else:
                panel_title = f"{drug_name} Calibration"

        # Panel customizations
        ax.axvspan(1280, 1292, color='#808080', alpha=1.0, zorder=0)
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_linewidth(0.8)
        ax.spines['bottom'].set_linewidth(0.8)
        ax.tick_params(axis='both', width=0.8, length=2, labelsize=7, colors='black')
        ax.set_xlim(0, 4200)
        ax.set_ylim(0, 115)  # Set a consistent y-limit
        ax.set_title(panel_title, fontsize=10, fontweight="bold")

        if i % num_cols == 0:  # Only on the first column
            ax.set_ylabel('Normalized Cell Count', fontsize=9, fontweight="bold")

        if i >= num_panels - num_cols:  # Only on the last row
            ax.set_xlabel('Time (min)', fontsize=9, fontweight="bold")

    # Hide unused subplots
    for i in range(num_panels, len(axes)):
        axes[i].set_visible(False)

    # Create a single legend for the entire figure
    handles, labels = axes[0].get_legend_handles_labels()
    
    # Create a unique legend
    unique_labels = {}
    for handle, label in zip(handles, labels):
        if label not in unique_labels:
            unique_labels[label] = handle
            
    # Add treatment handle
    from matplotlib.patches import Patch
    unique_labels['Treatment'] = Patch(color='#808080', label='Treatment')

    fig.legend(unique_labels.values(), unique_labels.keys(), loc='lower center', bbox_to_anchor=(0.5, -0.05), ncol=4, fontsize=9, frameon=False)

    plt.tight_layout(rect=[0, 0.05, 1, 1])  # Adjust layout to make space for legend

    # Save the figure
    plot_path_base = os.path.join(output_dir, plot_filename_base)
    fig.savefig(plot_path_base + ".png", dpi=300, bbox_inches='tight', transparent=True)
    fig.savefig(plot_path_base + ".svg", format='svg', bbox_inches='tight', transparent=True)
    logging.info(f"Multi-panel plot saved to {plot_path_base}.png")

    plt.close(fig)


def plot_rmse_violin_plot(experiment_infos, output_dir, filename_base):
    """
    Creates a violin plot of RMSE distributions for different experimental conditions.
    """
    logging.info("Creating RMSE violin plot...")

    rmse_data = []
    condition_order = []

    for exp_info_group in experiment_infos:
        # Get the main condition for this group (not WT/CTRL)
        main_exp = next((exp for exp in reversed(exp_info_group) if exp.get("drug_name") not in ["WT", "CTRL"]), None)
        if not main_exp:
            continue
        
        drug_name = main_exp.get("drug_name")
        rmses = main_exp.get("rmses")

        if rmses:
            if "MEK" in drug_name and ("PI3K" in drug_name or "AKT" in drug_name):
                condition_label = drug_name.replace("_", "+")
            else:
                 condition_label = drug_name
            
            if 'i' not in condition_label[-2:]:
                condition_label += 'i'
            
            condition_order.append(condition_label)
            for rmse in rmses:
                rmse_data.append({"Condition": condition_label, "RMSE": rmse})

    if not rmse_data:
        logging.warning("No RMSE data found to plot for violin plot.")
        return

    df = pd.DataFrame(rmse_data)

    fig, ax = plt.subplots(figsize=(10, 6), dpi=300)
    sns.set_context("paper", font_scale=1.2)
    sns.set_style("ticks")
    
    sns.violinplot(x="Condition", y="RMSE", data=df, order=condition_order, palette="muted", cut=0, ax=ax)
    
    ax.set_xlabel("Experimental Condition", fontsize=12, fontweight="bold")
    ax.set_ylabel("RMSE", fontsize=12, fontweight="bold")
    ax.set_title("Distribution of RMSE for Top Individuals", fontsize=14, fontweight="bold")
    ax.tick_params(axis='x', rotation=45, labelsize=10)

    sns.despine()
    plt.tight_layout()

    output_path = os.path.join(output_dir, f"{filename_base}.png")
    fig.savefig(output_path, dpi=300, bbox_inches='tight', transparent=True)
    fig.savefig(output_path.replace('.png', '.svg'), format='svg', bbox_inches='tight', transparent=True)
    plt.close(fig)

    logging.info(f"RMSE violin plot saved to {output_path}")


# single drug experiment fittings
best_control_experiment_name = "CTRL_CMA-1110-1637-5p"
# best_pi3k_experiment_name = "PI3Ki_CMA-2502-0113-18p_delayed_transient_rmse_postdrug_50gen" # "PI3Ki_CMA-1410-1014-12p_rmse_final_50gen"
# best_mek_experiment_name = "MEKi_CMA-2502-0113-18p_delayed_transient_rmse_postdrug_50gen" # "MEKi_CMA-1410-1026-12p_rmse_final_50gen"
# best_mek_experiment_name = "MEKi_CMA-1410-1026-12p_rmse_final_50gen"
# best_akt_experiment_name = "AKTi_CMA-1002-0147-8p_linear_mapping" # "AKTi_CMA-1710-0934-12p_rmse_final_50gen"

# OK FINAL EXPERIMENTS 
best_pi3k_experiment_name   = "PI3Ki_CMA-0704-1815-18p_delayed_transient_rmse_postdrug_25gen" # "PI3Ki_CMA-1410-1014-12p_rmse_final_50gen"
best_mek_experiment_name    = "MEKi_CMA-0704-1815-18p_delayed_transient_rmse_postdrug_25gen" # "MEKi_CMA-1410-1026-12p_rmse_final_50gen"
best_akt_experiment_name    = "AKTi_CMA-0704-1815-18p_delayed_transient_rmse_postdrug_25gen" # "AKTi_CMA-1710-0934-12p_rmse_final_50gen"

top_n = "10p"


# Define the experiments
control_single_drug_experiment = [
    {
        "name": best_control_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_control_experiment_name),
        "drug_name": get_drug_from_filename(best_control_experiment_name),
        "short_name": "CTRL_CMA_top10"
    }
]

pi3k_single_drug_experiment = [
    {
        "name": best_control_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_control_experiment_name),
        "drug_name": get_drug_from_filename(best_control_experiment_name),
        "short_name": "ctrlcma_t10"
    },
    {
        "name": best_pi3k_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_pi3k_experiment_name),
        "drug_name": get_drug_from_filename(best_pi3k_experiment_name),
        "short_name": "pi3kcma_18p_0704_1815_top10"
    }
]

mek_single_drug_experiment = [
    {
        "name": best_control_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_control_experiment_name),
        "drug_name": get_drug_from_filename(best_control_experiment_name),
        "short_name": "ctrlcma_t10"
    },
    {
        "name": best_mek_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_mek_experiment_name),
        "drug_name": get_drug_from_filename(best_mek_experiment_name),
        "short_name": "mekcma_18p_0704_1815_top10"
    }
]

akt_single_drug_experiment = [
    {
        "name": best_control_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_control_experiment_name),
        "drug_name": get_drug_from_filename(best_control_experiment_name),
        "short_name": "ctrlcma_t10"
    },
    {
        "name": best_akt_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_akt_experiment_name),
        "drug_name": get_drug_from_filename(best_akt_experiment_name),
        "short_name": "aktcma_18p_0704_1815_top10"
    }
]


# Combine and plot
# Create the folder if it does not exist
output_dir_single_drug = 'results/publication_plots/single_drug_calibration'
os.makedirs(output_dir_single_drug, exist_ok=True)


#########################
# SINGLE DRUG EXPERIMENTS
#########################

experimental_data_path = "/gpfs/projects/bsc08/bsc08494/AGS/EMEWS/data/AGS_data/AGS_growth_data/output/csv/"

################# Control #################

control_single_drug_experiment_info = []
# Process each experiment
for experiment in control_single_drug_experiment:
    csv_path = f'results/{experiment["strategy"]}_summaries/final_summary_{experiment["name"]}/top_{experiment["top_n"]}.csv'
    print("processing experiment", experiment)
    
    # Call process_top_10 for each experiment
    sim_stats, x_exp, y_exp, y_exp_std, rmses = process_top_10(csv_path, experiment["name"], experimental_data_path, experiment["drug_name"], experiment["top_n"], nodrug=True)

    # Append the experiment info
    control_single_drug_experiment_info.append({
        "name": experiment["name"],
        "top_n": experiment["top_n"],
        "strategy": experiment["strategy"],
        "drug_name": experiment["drug_name"],
        "short_name": experiment["short_name"],
        "data": (sim_stats, x_exp, y_exp, y_exp_std),
        "rmses": rmses
    })

# Call the modified combine_and_plot_experiments function
plot_filename_base = "growth_comparison_control_calibration"
combine_and_plot_experiments(control_single_drug_experiment_info, output_dir_single_drug, plot_filename_base)


################# PI3K #################

pi3k_single_drug_experiment_info = []
# Process each experiment
for experiment in pi3k_single_drug_experiment:
    csv_path = f'results/{experiment["strategy"]}_summaries/final_summary_{experiment["name"]}/top_{experiment["top_n"]}.csv'
    print("processing experiment", experiment)
    
    # Call process_top_10 for each experiment
    sim_stats, x_exp, y_exp, y_exp_std, rmses = process_top_10(csv_path, experiment["name"], experimental_data_path, experiment["drug_name"], experiment["top_n"])
    
    # # Add last generation processing
    # if "CTRL" not in experiment["name"]:
    #     last_gen_data = process_last_gen(experiment["name"], experimental_data_path, experiment["drug_name"])
    # else:
    #     last_gen_data = None
    
    # Append both to experiment info
    pi3k_single_drug_experiment_info.append({
        "name": experiment["name"],
        "top_n": experiment["top_n"],
        "strategy": experiment["strategy"],
        "drug_name": experiment["drug_name"],
        "short_name": experiment["short_name"],
        "data": (sim_stats, x_exp, y_exp, y_exp_std),
        "rmses": rmses
        # "last_gen_data": last_gen_data
    })

# Call the modified combine_and_plot_experiments function
plot_filename_base = "growth_comparison_pi3ki_calibration"
combine_and_plot_experiments(pi3k_single_drug_experiment_info, output_dir_single_drug, plot_filename_base)
side_by_side_experiment_plots(pi3k_single_drug_experiment_info, output_dir_single_drug, plot_filename_base)


################# MEK #################

mek_single_drug_experiment_info = []
# Process each experiment
for experiment in mek_single_drug_experiment:
    csv_path = f'results/{experiment["strategy"]}_summaries/final_summary_{experiment["name"]}/top_{experiment["top_n"]}.csv'
    print("processing experiment", experiment)
    
    # Call process_top_10 for each experiment
    sim_stats, x_exp, y_exp, y_exp_std, rmses = process_top_10(csv_path, experiment["name"], experimental_data_path, experiment["drug_name"], experiment["top_n"])

    # # Add last generation processing
    # if "CTRL" not in experiment["name"]:
    #     last_gen_data = process_last_gen(experiment["name"], experimental_data_path, experiment["drug_name"])
    # else:
    #     last_gen_data = None
    
    # Append both to experiment info
    mek_single_drug_experiment_info.append({
        "name": experiment["name"],
        "top_n": experiment["top_n"],
        "strategy": experiment["strategy"],
        "drug_name": experiment["drug_name"],
        "short_name": experiment["short_name"],
        "data": (sim_stats, x_exp, y_exp, y_exp_std),
        "rmses": rmses
        # "last_gen_data": last_gen_data
        })
    
# Call the modified combine_and_plot_experiments function
plot_filename_base = "growth_comparison_meki_calibration"
combine_and_plot_experiments(mek_single_drug_experiment_info, output_dir_single_drug, plot_filename_base)
side_by_side_experiment_plots(mek_single_drug_experiment_info, output_dir_single_drug, plot_filename_base)

# ################# AKT #################

akt_single_drug_experiment_info = []
# Process each experiment
for experiment in akt_single_drug_experiment:
    csv_path = f'results/{experiment["strategy"]}_summaries/final_summary_{experiment["name"]}/top_{experiment["top_n"]}.csv'
    print("processing experiment", experiment)
    
    # Call process_top_10 for each experiment
    sim_stats, x_exp, y_exp, y_exp_std, rmses = process_top_10(csv_path, experiment["name"], experimental_data_path, experiment["drug_name"], experiment["top_n"])

    print("THIS IS THE EXPERIMENT DATA FOR AKT", exp_data)

    # Add last generation processing
    # if "CTRL" not in experiment["name"]:
    #     last_gen_data = process_last_gen(experiment["name"], experimental_data_path, experiment["drug_name"])
    # else:
    #     last_gen_data = None
    
    # Append the experiment info
    akt_single_drug_experiment_info.append({
        "name": experiment["name"],
        "top_n": experiment["top_n"],
        "strategy": experiment["strategy"],
        "drug_name": experiment["drug_name"],
        "short_name": experiment["short_name"],
        "data": (sim_stats, x_exp, y_exp, y_exp_std),
        "rmses": rmses
        # "last_gen_data": last_gen_data
    })

# Call the modified combine_and_plot_experiments function
plot_filename_base = "growth_comparison_akti_calibration"
combine_and_plot_experiments(akt_single_drug_experiment_info, output_dir_single_drug, plot_filename_base)
side_by_side_experiment_plots(akt_single_drug_experiment_info, output_dir_single_drug, plot_filename_base)

########################
# SYNERGY EXPERIMENTS #
########################

best_pi3kmek_combined_experiment_name = "synergy_sweep-pi3k_mek-1104-2212-18p_transient_delayed_uniform_5k_10p"
best_pi3kmek_PI3K_singledrug_experiment_name = "synergy_sweep-pi3k_mek-1104-2212-18p_PI3K_transient_delayed_uniform_5k_10p"
best_pi3kmek_MEK_singledrug_experiment_name = "synergy_sweep-pi3k_mek-1104-2212-18p_MEK_transient_delayed_uniform_5k_10p"

best_aktmek_combined_experiment_name = "synergy_sweep-akt_mek-1204-1639-18p_transient_delayed_uniform_postdrug_RMSE_5k"
best_aktmek_AKT_singledrug_experiment_name = "synergy_sweep-akt_mek-1104-2212-18p_AKT_transient_delayed_uniform_5k_singledrug"
best_aktmek_MEK_singledrug_experiment_name = "synergy_sweep-akt_mek-1104-2212-18p_MEK_transient_delayed_uniform_5k_singledrug"


# Linear mapping experiments
# best_pi3kmek_combined_experiment_name = "synergy_sweep-pi3k_mek-1102-1909-8p_linear_mapping_uniform_5k"
# best_pi3kmek_PI3K_singledrug_experiment_name = "synergy_sweep-pi3k_mek-1102-1909-8p_PI3K_linear_mapping_singledrug"
# best_pi3kmek_MEK_singledrug_experiment_name = "synergy_sweep-pi3k_mek-1102-1909-8p_MEK_linear_mapping_singledrug"


# best_aktmek_combined_experiment_name = "synergy_sweep-akt_mek-1102-1909-8p_linear_mapping_uniform_5k"
# best_aktmek_AKT_singledrug_experiment_name = "synergy_sweep-akt_mek-1102-1909-8p_AKT_linear_mapping_singledrug"
# best_aktmek_MEK_singledrug_experiment_name = "synergy_sweep-akt_mek-1102-1909-8p_MEK_linear_mapping_singledrug"


pi3k_mek_synergy_experiments = [
    {
        "name": best_control_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_control_experiment_name),
        "drug_name": get_drug_from_filename(best_control_experiment_name),
        "short_name": "CTRL_CMA_top10"
    },
    {
        "name": best_pi3kmek_PI3K_singledrug_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_pi3kmek_PI3K_singledrug_experiment_name),
        "drug_name": get_drug_from_filename(best_pi3kmek_PI3K_singledrug_experiment_name),
        "short_name": "PI3K_sweep_top10"
    },
    {
        "name": best_pi3kmek_MEK_singledrug_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_pi3kmek_MEK_singledrug_experiment_name),
        "drug_name": get_drug_from_filename(best_pi3kmek_MEK_singledrug_experiment_name),
        "short_name": "MEK_sweep_top10"
    },
    {
        "name": best_pi3kmek_combined_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_pi3kmek_combined_experiment_name),
        "drug_name": get_drug_from_filename(best_pi3kmek_combined_experiment_name),
        "short_name": "PI3KMEK_top10_final_rmse"
    }
]

akt_mek_synergy_experiments = [
    {
        "name": best_control_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_control_experiment_name),
        "drug_name": get_drug_from_filename(best_control_experiment_name),
        "short_name": "CTRL_CMA_top10"
    },
    {
        "name": best_aktmek_AKT_singledrug_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_aktmek_AKT_singledrug_experiment_name),
        "drug_name": get_drug_from_filename(best_aktmek_AKT_singledrug_experiment_name),
        "short_name": "AKT_sweep_top10"
    },
    {
        "name": best_aktmek_MEK_singledrug_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_aktmek_MEK_singledrug_experiment_name),
        "drug_name": get_drug_from_filename(best_aktmek_MEK_singledrug_experiment_name),
        "short_name": "MEK_sweep_top10"
    },
    {
        "name": best_aktmek_combined_experiment_name,
        "top_n": 10,
        "strategy": get_strategy_from_filename(best_aktmek_combined_experiment_name),
        "drug_name": get_drug_from_filename(best_aktmek_combined_experiment_name),
        "short_name": "AKTMEK_top10_final_rmse"
    }
]

# Combine and plot
# Create the folder if it does not exist
output_dir_synergy = 'results/publication_plots/synergy_comparison'
os.makedirs(output_dir_synergy, exist_ok=True)


####################
# PI3K MEK SYNERGY #
####################

experiment_info_pi3k_mek_synergy = []
# Process each experiment
for experiment in pi3k_mek_synergy_experiments:
    experimental_data_path = "/gpfs/projects/bsc08/bsc08494/AGS/EMEWS/data/AGS_data/AGS_growth_data/output/csv/"

    if experiment['strategy'] == 'sweep':
        # For sweeps, the top N are in the main summary file, not a separate top_n.csv
        csv_path = f'results/{experiment["strategy"]}_summaries/final_summary_{experiment["name"]}.csv'
    else:
        # For CMA/GA, the path points to the pre-generated top_n.csv
        csv_path = f'results/{experiment["strategy"]}_summaries/final_summary_{experiment["name"]}/top_{experiment["top_n"]}.csv'

    print("processing experiment", experiment)
    
    exp_data = process_top_10(csv_path, experiment["name"], experimental_data_path, experiment["drug_name"], experiment["top_n"])
    sim_stats, x_exp, y_exp, y_exp_std, rmses = exp_data

    # Append the experiment info
    experiment_info_pi3k_mek_synergy.append({
        "name": experiment["name"],
        "top_n": experiment["top_n"],
        "strategy": experiment["strategy"],
        "drug_name": experiment["drug_name"],
        "short_name": experiment["short_name"],
        "data": (sim_stats, x_exp, y_exp, y_exp_std),
        "rmses": rmses
    })
# # Call the modified combine_and_plot_experiments function
plot_filename_base = "growth_comparison_pi3ki_meki_synergy"
combine_and_plot_experiments(experiment_info_pi3k_mek_synergy, output_dir_synergy, plot_filename_base)
side_by_side_experiment_plots(experiment_info_pi3k_mek_synergy, output_dir_synergy, plot_filename_base)


####################
# AKT MEK SYNERGY #
####################

experiment_info_akt_mek_synergy = []
# Process each experiment
for experiment in akt_mek_synergy_experiments:
    experimental_data_path = "/gpfs/projects/bsc08/bsc08494/AGS/EMEWS/data/AGS_data/AGS_growth_data/output/csv/"

    if experiment['strategy'] == 'sweep':
        # For sweeps, the top N are in the main summary file
        csv_path = f'results/{experiment["strategy"]}_summaries/final_summary_{experiment["name"]}.csv'
    else:
        # For CMA/GA, path points to the pre-generated top_n.csv
        csv_path = f'results/{experiment["strategy"]}_summaries/final_summary_{experiment["name"]}/top_{experiment["top_n"]}.csv'

    print("processing experiment", experiment)
    
    # Call process_top_10 for each experiment
    sim_stats, x_exp, y_exp, y_exp_std, rmses = process_top_10(csv_path, experiment["name"], experimental_data_path, experiment["drug_name"], experiment["top_n"])
    
    # Append the experiment info
    experiment_info_akt_mek_synergy.append({
        "name": experiment["name"],
        "top_n": experiment["top_n"],
        "strategy": experiment["strategy"],
        "drug_name": experiment["drug_name"],
        "short_name": experiment["short_name"],
        "data": (sim_stats, x_exp, y_exp, y_exp_std),
        "rmses": rmses
    })

# Call the modified combine_and_plot_experiments function
plot_filename_base = "growth_comparison_akti_meki_synergy"
combine_and_plot_experiments(experiment_info_akt_mek_synergy, output_dir_synergy, plot_filename_base)
side_by_side_experiment_plots(experiment_info_akt_mek_synergy, output_dir_synergy, plot_filename_base)

#################################
# FINAL MULTI-PANEL SUMMARY PLOTS
#################################

# 1. Single-drug calibration summary plot
all_single_drug_experiments = [
    pi3k_single_drug_experiment_info, 
    mek_single_drug_experiment_info, 
    akt_single_drug_experiment_info
]
plot_multi_panel_figure(
    list_of_experiment_groups=all_single_drug_experiments,
    num_cols=3,
    output_dir=output_dir_single_drug,
    plot_filename_base="summary_single_drug_calibrations",
    is_synergy=False
)

# 2. Synergy comparison summary plot
all_synergy_experiments = [
    experiment_info_pi3k_mek_synergy,
    experiment_info_akt_mek_synergy
]
plot_multi_panel_figure(
    list_of_experiment_groups=all_synergy_experiments,
    num_cols=2,
    output_dir=output_dir_synergy,
    plot_filename_base="summary_synergy_comparisons",
    is_synergy=True
)

# 3. RMSE Violin Plot
all_experiments_for_violin = [
    pi3k_single_drug_experiment_info,
    mek_single_drug_experiment_info,
    akt_single_drug_experiment_info,
    experiment_info_pi3k_mek_synergy,
    experiment_info_akt_mek_synergy,
]
violin_output_dir = 'results/publication_plots/'
os.makedirs(violin_output_dir, exist_ok=True)
plot_rmse_violin_plot(all_experiments_for_violin, violin_output_dir, "rmse_distribution_summary")

